#!@@PERL@@ -T
# -*- cperl -*-

=begin comment

Copyright (C) 2013 Steve Schnepp

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; version 2 dated June,
1991.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=end comment

=cut

use strict;
use warnings;


use CGI::Fast qw(:cgi);
use CGI::Carp qw(fatalsToBrowser);

use POSIX;
use HTML::Template::Pro;

use Munin::Master::Utils;

use Munin::Common::Logger;

use File::Basename;
use Data::Dumper;

my @times = qw(day week month year);

while (new CGI::Fast) {
	my $path = path_info();

	# Handle static page now, since there is no need to do any SQL
	if ($path =~ m/static\/(.+)$/) {
		# Emit the static page
		my $page = $1;
		my ($ext) = ($page =~ m/.*\.([^.]+)$/);
		my %mime_types = (
			css => "text/css",
			html => "text/html",
			png => "image/png",
			jpg => "image/jpeg",
			jpeg => "image/jpeg",
			js => "application/javascript",
		);

		my $filename = get_param("staticdir"). "/$page";
		my $fh = new IO::File("$filename");

		if (! $fh) {
			print header( -status => 404);
			next;
		}

		print header( -status => 200, -type => $mime_types{$ext});
		while (my $line = <$fh>) { print $line; }
		next;
	}

	# Short evaluate the GRAPH png pages
	if ($path =~ m/-(day|week|month|year).png$/) {
		my $url = script_name() . "/../munin-cgi-graph" . path_info();
		print header(
			-status => 301,
			-Location => $url,
			-Cache_Control => "public, max-age=14400",  # Cache is valid of 1 day
		);
		next;
	}

	# Force either a trailing "/" or ".html" to enable simpler url handling: it is like in
	# a subdir from the browser pov
	if ($path eq "" || $path !~ /(\/|\.html)$/) {
		#if ($path eq "") {
		print header(
			-status => 301,
			-Location => (url(-path_info=>1,-query=>1) . "/"),
			-Cache_Control => "public, max-age=14400",  # Cache is valid of 1 day
		);
		next;
	}

	# Remove now the leading "/" as *every* path will have it
	$path =~ s,^/,,;

	# Remove now the ending "/" as *every* dir will have it
	$path =~ s,/$,,;

	# Ok, now SQL is needed to go further
        use DBI;
	my $datafilename = "$Munin::Common::Defaults::MUNIN_DBDIR/datafile.sqlite";
        my $dbh = DBI->connect("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;

	my $template_filename;
	my %template_params = (
		MUNIN_VERSION	=> $Munin::Common::Defaults::MUNIN_VERSION,
		TIMESTAMP       => strftime("%Y-%m-%d %T%z (%Z)", localtime),
		R_PATH		=> script_name(),
	);

	# Common Navigation params
	###################

	# Problems nav
	{
		my $sth = $dbh->prepare_cached("SELECT SUM(critical), SUM(warning), SUM(unknown) FROM ds");
		$sth->execute();
		my ($critical, $warning, $unknown) = $sth->fetchrow_array;
		$template_params{NCRITICAL} = $critical;
		$template_params{NWARNING} = $warning;
		$template_params{NUNKNOWN} = $unknown;
	}

	# Groups nav
	{
		my $sth = $dbh->prepare_cached("SELECT g.name, u.path FROM grp g INNER JOIN url u ON u.id = g.id AND u.type = 'group' ORDER BY g.name ASC");
		$sth->execute();

		my $rootgroups = [];
		while (my ($_name, $_path) = $sth->fetchrow_array) {
			push @$rootgroups, { NAME => $_name, R_PATH => script_name(), URL => $_path };
		}
		$template_params{ROOTGROUPS} = $rootgroups;
	}

	# Categories nav
	{
		my $sth = $dbh->prepare_cached("SELECT DISTINCT value FROM service_attr WHERE name = 'graph_category' ORDER BY value ASC");
		$sth->execute();

		my $globalcats = [];
		while (my ($_category) = $sth->fetchrow_array) {
			my %urls = map { ("URL$_" => "$_category-$_.html") } @times;
			push @$globalcats, {
				R_PATH => script_name(),
				NAME => $_category,
				%urls,
			};
		}
		$template_params{GLOBALCATS} = $globalcats;
	}

	# Handle all the special pages that are not in the url table, but with fixed urls
	if ($path eq "") {
		# Emit overview template
		$template_filename = 'munin-overview.tmpl';

		# Header params
		###################
		{
			$template_params{PATH} = [
				{ } , # XXX - Template says first args has to be empty
				{ "pathname" => "Overview", },
			];
		}

		# Main page
		{
			# Constructing the recursive datastructure.
			# Note that it is quite naive, and not optimized for speed.
			my $sth_grp = $dbh->prepare_cached("SELECT g.id, g.name, u.path FROM grp g INNER JOIN url u ON u.id = g.id AND u.type = 'group' AND p_id = ? ORDER BY g.name ASC");
			my $sth_grp_root = $dbh->prepare_cached("SELECT g.id, g.name, u.path FROM grp g INNER JOIN url u ON u.id = g.id AND u.type = 'group' AND p_id IS NULL ORDER BY g.name ASC");
			my $sth_node = $dbh->prepare_cached("SELECT n.id, n.name, u.path, n.path FROM node n INNER JOIN url u ON u.id = n.id AND u.type = 'node' AND n.grp_id = ? ORDER BY n.name ASC");

			$template_params{GROUPS} = _get_params_groups($path, $dbh, $sth_grp, $sth_grp_root, $sth_node, undef);
		}

		# TODO - We still have to write the bottom navigation links
	} elsif ($path eq "dynazoom.html") {
		# Emit dynamic zoom template

		$template_params{SHOW_ZOOM_JS} = 1;
		$template_params{PATH} = [
			# first args should have path and r_path for backlink to overview
			{ "r_path" => url_absolutize(''), "path" => url_absolutize(''), },
		];

		$template_filename = "munin-dynazoom.tmpl";
	} elsif ($path eq "problems.html") {
		# Emit problem template

		$template_filename = "munin-problemview.tmpl";

		# TODO - Create the model (problem)
	} elsif ($path =~ /^([^\/])+-(day|month|week|year)\.html$/) {
		# That's a category URL
		$template_filename = 'munin-categoryview.tmpl';

		my $category = $1;
		my $time = $2;

		$template_params{PATH} = [
			{ } , # XXX - Template says first args has to be empty
			{ "pathname" => "Category", },
		];

		# TODO - Create the model (category)
	}

	# Handle normal pages only if not aleady handled
	goto RENDERING if $template_filename;

	# Remove an eventual [/index].html
	$path =~ s/(\/index)?\.html$//;

	my $sth_url = $dbh->prepare_cached("SELECT id, type FROM url WHERE path = ?");
	$sth_url->execute($path);
	my ($id, $type) = $sth_url->fetchrow_array;

	if (! defined $id) {
		# Not found
		print header( -status => 404, );
		next;
	} elsif ($type eq "group") {
		# Emit group template
		$template_filename = 'munin-domainview.tmpl';


		# Main page
		{
			# Constructing the recursive datastructure.
			# Note that it is quite naive, and not optimized for speed.
			my $sth_grp = $dbh->prepare_cached("SELECT g.id, g.name, u.path FROM grp g INNER JOIN url u ON u.id = g.id AND u.type = 'group' AND p_id = ? ORDER BY g.name ASC");
			my $sth_grp_root = $dbh->prepare_cached("SELECT g.id, g.name, u.path FROM grp g INNER JOIN url u ON u.id = g.id AND u.type = 'group' AND p_id IS NULL ORDER BY g.name ASC");
			my $sth_node = $dbh->prepare_cached("SELECT n.id, n.name, u.path, n.path FROM node n INNER JOIN url u ON u.id = n.id AND u.type = 'node' AND n.grp_id = ? ORDER BY n.name ASC");

			$template_params{GROUPS} = _get_params_groups($path, $dbh, $sth_grp, $sth_grp_root, $sth_node, $id);

			my $sth_p_id = $dbh->prepare_cached("SELECT g.p_id FROM grp g WHERE g.id = ?");
			$sth_p_id->execute($id);
			my ($_p_id) = $sth_p_id->fetchrow_array;
			my $sth_peer;

			# Check for top level groups
			if (defined $_p_id) {
				$sth_peer = $sth_grp;
				$sth_peer->execute($id);
			} else {
				$sth_peer = $sth_grp_root;
				$sth_peer->execute();
			}

			# Construct list of peers
			my $peers = [];
			while (my (undef, $_name, $_url) = $sth_peer->fetchrow_array) {
				$_url =~ s!/$!!;
				push @$peers, { NAME => $_name, LINK => '../' . basename($_url) . '/' };
			}

			$template_params{PEERS} = $peers;
			$template_params{LARGESET} = 1;
			$template_params{INFO_OPTION} = 'Groups on this level';

			$template_params{PATH} = [
				# first args should have path and r_path for backlink to overview
				{ "r_path" => url_absolutize(''), "path" => url_absolutize(''), },
				url_to_path($path),
			];

			$template_params{NAME} = $template_params{PATH}[-1]{'pathname'};

			# Shows "[ d w m y ]"
			$template_params{COMPARE} = 1;
		}

	} elsif ($type eq "node") {
		# Emit node template
		$template_filename = 'munin-nodeview.tmpl';

		# Construct list of peers
		my $sth_peer = $dbh->prepare_cached(
			"SELECT n.name, u.path FROM node n
			INNER JOIN url u ON n.id = u.id AND u.type = 'node'
			WHERE n.grp_id = (SELECT n.grp_id FROM node n WHERE n.id = ?)
			ORDER BY n.name ASC");
		$sth_peer->execute($id);

		my $peers = [];
		while (my ($_name, $_url) = $sth_peer->fetchrow_array) {
			push @$peers, { NAME => $_name, LINK => '../' . basename($_url) . "/" };
		}

		$template_params{PEERS} = $peers;
		$template_params{LARGESET} = 1;
		$template_params{INFO_OPTION} = 'Nodes on this level';

		my $sth_category = $dbh->prepare(
			"SELECT DISTINCT sa.value as graph_category FROM service s
			INNER JOIN service_attr sa ON sa.id = s.id AND sa.name = 'graph_category'
			WHERE s.node_id = ?
			ORDER BY graph_category");
		$sth_category->execute($id);

		my $categories = [];
		while (my ($_category_name) = $sth_category->fetchrow_array) {
			push @$categories, _get_params_services($path, $dbh, $_category_name, undef, $id);
		}

		$template_params{CATEGORIES} = $categories;
		$template_params{NCATEGORIES} = scalar(@$categories);

		$template_params{PATH} = [
			# first args should have path and r_path for backlink to overview
			{ "r_path" => url_absolutize(''), "path" => url_absolutize(''), },
			url_to_path($path),
		];

		$template_params{NAME} = $template_params{PATH}[-1]{'pathname'};

	} elsif ($type eq "service") {
		# Emit service template
		$template_filename = 'munin-serviceview.tmpl';

		my $sth;

		$sth = $dbh->prepare_cached("SELECT name FROM service WHERE id = ?");
		$sth->execute($id);
		my ($graph_name) = $sth->fetchrow_array();

		$sth = $dbh->prepare_cached("SELECT value FROM service_attr WHERE id = ? and name = 'graph_category'");
		$sth->execute($id);
		my ($graph_category) = $sth->fetchrow_array();

		$sth = $dbh->prepare_cached("SELECT value FROM service_attr WHERE id = ? and name = 'graph_info'");
		$sth->execute($id);
		my ($graph_info) = $sth->fetchrow_array();

		$sth = $dbh->prepare_cached("SELECT value FROM service_attr WHERE id = ? and name = 'subgraphs'");
		$sth->execute($id);
		my ($multigraph) = $sth->fetchrow_array();

		$sth = $dbh->prepare_cached("SELECT n.id FROM node n INNER JOIN service s ON s.node_id = n.id WHERE s.id = ?");
		$sth->execute($id);
		my ($node_id) = $sth->fetchrow_array();

		# Generate peers
		my ($graph_parent) = ($graph_name =~ /^(.*)\./);
		$template_params{PEERS} = [ map {
			(my $name = basename($_->{"URLX"}, ".html")) =~ tr/_/ /;
			{ NAME => $name, LINK => $multigraph ? ("../" . $_->{URLX}) : $_->{URLX}, }
		} @{_get_params_services(dirname($path), $dbh, $graph_category, $graph_parent, $node_id)->{SERVICES}} ];
		$template_params{LARGESET} = 1;
		$template_params{INFO_OPTION} = 'Graphs in same category';

		$template_params{PATH} = [
			# first args should have path and r_path for backlink to overview
			{ "r_path" => url_absolutize(''), "path" => url_absolutize(''), },
			url_to_path($path),
		];

		$template_params{CATEGORY} = ucfirst($graph_category);

		if ($multigraph) {
			# Emit node template for multigraphs
			$template_filename = 'munin-nodeview.tmpl';

			my @categories = (_get_params_services($path, $dbh, $graph_category, $graph_name, $node_id));
			$template_params{CATEGORIES} = \@categories;
			$template_params{NCATEGORIES} = scalar(@categories);
			$template_params{NAME} = $template_params{PATH}[-1]{'pathname'};

			goto RENDERING;
		}

		# Create the params
		my %service_template_params;
		$service_template_params{FIELDINFO} = _get_params_fields($dbh, $id);
		my $cgi_graph_url = script_name() . "/../munin-cgi-graph/";
		my $epoch_now = time;
		my %epoch_start = (
			day => $epoch_now - (3600 * 30),
			week => $epoch_now - (3600 * 24 * 8),
			month => $epoch_now - (3600 * 24 * 33),
			year => $epoch_now - (3600 * 24 * 400),
		);

		for my $t (@times) {
			my $epoch = "start_epoch=$epoch_start{$t}&stop_epoch=$epoch_now";
			$service_template_params{"ZOOM$t"} = script_name() . "/dynazoom.html?cgiurl_graph=$cgi_graph_url" .
				"&plugin_name=$path&size_x=800&size_y=400&$epoch";
			$service_template_params{"IMG$t"} = $cgi_graph_url . "$path-$t.png";
		}

		# template uses loop for no apparent reason
		$service_template_params{GRAPHINFO} = [ { info => $graph_info } ];

		$template_params{SERVICES} = [ \%service_template_params,];
	}

RENDERING:
	if (! $template_filename ) {
		# Unknown
		print header( -status => 404, );
		next;
	}

	print header( -status => 200, "-Content-Type" => "text/html", );
	my $template = HTML::Template::Pro->new(
		filename => "$Munin::Common::Defaults::MUNIN_CONFDIR/templates/$template_filename",
		loop_context_vars => 1,
	);

	{
		use Data::Dumper;
		local $Data::Dumper::Terse = 1;
		local $Data::Dumper::Sortkeys = 1;
		local $Data::Dumper::Sparseseen = 1;
		local $Data::Dumper::Deepcopy = 1;
		local $Data::Dumper::Indent = 1;

		$template_params{DEBUG} = Dumper(\%template_params);
	}


	$template->param(%template_params);

	# We cannot use "print_to => \*STDOUT" since it does *NOT* work with FastCGI
	print $template->output();
}

sub _get_params_groups {
	my ($path, $dbh, $sth_grp_normal, $sth_grp_root, $sth_node, $g_id) = @_;

	my $sth_grp;
	if (defined $g_id) {
		$sth_grp = $sth_grp_normal;
		$sth_grp->execute($g_id);
	} else {
		$sth_grp = $sth_grp_root;
		$sth_grp->execute();
	}

	my $groups = [];
	while (my ($_g_id, $_name, $_path) = $sth_grp->fetchrow_array) {
		push @$groups, {
			NAME => $_name,
			URL => "$_path/",
			GROUPS => _get_params_groups($path, $dbh, $sth_grp_normal, $sth_grp_root, $sth_node, $_g_id),
			COMPARE => 1,
			PATH => [
				{ PATH => '..', PATHNAME => undef, },
				{ PATH => '', PATHNAME => $_name, },
			],
		};
	}

	# Add the nodes
	$sth_node->execute($g_id);
	while (my ($_n_id, $_name, $_path) = $sth_node->fetchrow_array) {
		my $sth = $dbh->prepare_cached("SELECT DISTINCT sa.value FROM service s INNER JOIN service_attr sa ON sa.id = s.id AND sa.name = 'graph_category' WHERE s.node_id = ? ORDER BY sa.value ASC");
		$sth->execute($_n_id);

		# trim off current path from target's path
		substr($_path, 0, 1 + length($path)) = '' if $path;

		my $categories = [];
		while (my ($_category_name) = $sth->fetchrow_array) {
			my $category = _get_params_services($path, $dbh, $_category_name, undef, $_n_id);
			$category->{URLX} = "$_path/" . "#" . $_category_name;
			$category->{URL} = $category->{URLX}; # For category in overview
			push @$categories, $category;
		}

		push @$groups, {
			CATEGORIES => $categories,
			NCATEGORIES => (scalar @$categories), # This is a node.
			NAME => $_name,
			URL => "$_path/",
			URLX => "$_path/",
			GROUPS => [],
		};
	}

	return $groups;
}

sub _get_params_services {
	my ($base_path, $dbh, $category_name, $multigraph_parent, $node_id) = @_;

	my $sth = $dbh->prepare_cached("SELECT s.id, s.name, sa_t.value as service_title, sa_s.value as subgraphs, u.path AS url
		FROM service s
		INNER JOIN service_attr sa_c ON sa_c.id = s.id AND sa_c.name = 'graph_category' AND sa_c.value = ?
		INNER JOIN service_attr sa_t ON sa_t.id = s.id AND sa_t.name = 'graph_title'
		LEFT JOIN service_attr sa_s ON sa_s.id = s.id AND sa_s.name = 'subgraphs'
		INNER JOIN url u ON u.id = s.id AND u.type = 'service'
		WHERE s.node_id = ?
		ORDER BY service_title ASC");
	$sth->execute($category_name, $node_id);

	my $services = [];
	while (my ($_s_id, $_s_name, $_service_title, $_subgraphs, $_url) = $sth->fetchrow_array) {
		# Skip sub-graphs if not in multigraph
		next if not $multigraph_parent and $_s_name =~ /\./;
		# Skip unrelated graphs if in multigraph
		next if $multigraph_parent and $_s_name !~ /^$multigraph_parent\./;

		my %imgs = map { ("IMG$_" => script_name() . "/../munin-cgi-graph" . "/$_url-$_.png") } @times;
		push @$services, {
			NAME => $_service_title,
			URLX => substr($_url, 1 + length($base_path)) . ($_subgraphs ? "/" : ".html"),
			%imgs,
		};
	}


	return {
		NAME => $category_name,
		SERVICES => $services,
	};
}

sub _get_params_fields {
	my ($dbh, $service_id) = @_;

	my $sth_ds = $dbh->prepare_cached("
		SELECT ds.name, ds.warning, ds.critical,
		a_g.value, a_l.value, IFNULL(a_t.value, 'GAUGE'), a_w.value, a_c.value, a_i.value
		FROM ds
		LEFT JOIN ds_attr a_g ON ds.id = a_g.id AND a_g.name = 'graph'
		LEFT JOIN ds_attr a_l ON ds.id = a_l.id AND a_l.name = 'label'
		LEFT JOIN ds_attr a_t ON ds.id = a_t.id AND a_t.name = 'type'
		LEFT JOIN ds_attr a_w ON ds.id = a_w.id AND a_w.name = 'warning'
		LEFT JOIN ds_attr a_c ON ds.id = a_c.id AND a_c.name = 'critical'
		LEFT JOIN ds_attr a_i ON ds.id = a_i.id AND a_i.name = 'info'
		WHERE ds.service_id = ?
		ORDER BY ds.id ASC");
	$sth_ds->execute($service_id);

	my @fields;
	while (my ($_ds_name, $_ds_s_warn, $_ds_s_crit, $_ds_graph, $_ds_label, $_ds_type, $_ds_warn, $_ds_crit, $_ds_info) =
			$sth_ds->fetchrow_array) {
		next if $_ds_graph eq 'no';

		push @fields, {
			FIELD => $_ds_name,
			STATE_WARNING => $_ds_s_warn,
			STATE_CRITICAL => $_ds_s_crit,
			LABEL => $_ds_label,
			TYPE => lc($_ds_type),
			WARN => $_ds_warn,
			CRIT => $_ds_crit,
			INFO => $_ds_info,
		};
	}

	return \@fields;
}

sub get_param
{
	my ($param) = @_;

	# Ok, now SQL is needed to go further
        use DBI;
	my $datafilename = "$Munin::Common::Defaults::MUNIN_DBDIR/datafile.sqlite";
        my $dbh = DBI->connect("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;

	my ($value) = $dbh->selectrow_array("SELECT value FROM param WHERE name = ?", undef, ($param));

	return $value;
}

sub url_to_path
{
	my ($url) = @_;

	my @paths = split m!/!, $url;

	@paths = map {
		(my $name = $paths[$_]) =~ tr/_/ /;
		{
			'pathname' => $name,
			'path' => url_absolutize(join '/', @paths[0..$_]) . '/',
		}
	} 0..$#paths;

	delete $paths[-1]{'path'};

	return @paths;
}

sub url_absolutize
{
	my ($url, $omit_first_slash) = @_;
	my $url_a = script_name() . "/" . $url;
	$url_a = substr($url_a, 1) if $omit_first_slash;
	return $url_a;
}
