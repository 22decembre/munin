#!@@PERL@@ -T
# -*- cperl -*-

=begin comment

Copyright (C) 2014 Steve Schnepp

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; version 2 dated June,
1991.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=end comment

=cut

use strict;
use warnings;


use Time::HiRes;
use CGI::Fast;
#use CGI::Carp qw(fatalsToBrowser);

use POSIX;

use Munin::Master::Utils;

use Munin::Common::Logger;

use File::Basename;
use Data::Dumper;

Munin::Common::Logger::configure( level => 'debug', output => 'screen');

# Hash of available palettes
my %PALETTE;
# Array of actuall colours to use
my @COLOUR;

{
	no warnings;
	# This is the old munin palette. Note that it lacks contrast.
	$PALETTE{'old'} = [
		qw(22ff22 0022ff ff0000 00aaaa ff00ff
			ffa500 cc0000 0000cc 0080C0 8080C0 FF0080
			800080 688e23 408080 808000 000000 00FF00
			0080FF FF8000 800000 FB31FB
	)];

	# New default palette. Better contrast & more colours
	# Line variations: Pure, earthy, dark pastel, misc colours
	$PALETTE{'default'} = [
		#Greens Blues   Oranges Dk yel  Dk blu  Purple  lime    Reds    Gray
		qw(00CC00 0066B3 FF8000 FFCC00 330099 990099 CCFF00 FF0000 808080
			008F00 00487D B35A00 B38F00	 6B006B 8FB300 B30000 BEBEBE
			80FF80 80C9FF FFC080 FFE680 AA80FF EE00CC FF8080
			666600 FFBFFF 00FFCC CC6699 999900
	)];
}

# Obviously use the default one
@COLOUR = @{ $PALETTE{'default'} };

# those colors are used for single-valued plugins
my $range_colour  = "22ff22";
my $single_colour = "00aa00";

# Use 400 x RRA step, in order to have 1px per RRA sample.
my %times = (
	"hour"  => "-4000s",  # (i.e. -1h6m40s)
	"day"   => "-2000m",  # (i.e. -33h20m)
	"week"  => "-12000m", # (i.e. -8d13h20m)
	"month" => "-48000m", # (i.e. -33d8h)
	"year"  => "-400d",
	"pinpoint"  => "dummy",
);

my %resolutions = (
	"hour"  => "10",
	"day"   => "300",
	"week"  => "1500",
	"month" => "7200",
	"year"  => "86400"
);

my $watermark = "Munin " . $Munin::Common::Defaults::MUNIN_VERSION;

while (new CGI::Fast) {
	my $t0 = Time::HiRes::time;
	my $path = path_info();

	if ($path !~ m/^\/(.*)-(hour|day|week|month|year|pinpoint=(\d+),(\d+))\.(svg|json|csv|xml|png|[a-z]+)$/) {
		# We don't understand this URL
		print header(
			-status => 404,
			"X-Reason" => "invalid URL: $path",
		);
		next;
	}


	my ($graph_path, $time, $start, $end, $format) = ($1, $2, $3, $4, $5);
	$start = $times{$time} unless defined $start;
	$end = "" unless defined $end;

	# Handle the "pinpoint" time
	$time = "pinpoint" if $time =~ m/^pinpoint/;

	# Ok, now SQL is needed to go further
	use DBI;
	my $datafilename = "$Munin::Common::Defaults::MUNIN_DBDIR/datafile.sqlite";
	# Note that we reconnect for _each_ request. This is to avoid old data when the DB "rotates"
	my $dbh = DBI->connect("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;

	DEBUG "($graph_path, $time, $start, $end, $format)\n";

	# Find the service to display
	my $sth_url = $dbh->prepare_cached("SELECT id, type FROM url WHERE path = ?");
	$sth_url->execute($graph_path);
	my ($id, $type) = $sth_url->fetchrow_array;

	if (! defined $id) {
		# Not found
		print header(
			-status => 404,
			"X-Reason" => "'$graph_path' Not Found in DB",
		);
		next;
	} elsif ($type ne "service") {
		# Not supported yet
		print header(
			-status => 404,
			"X-Reason" => "'$type' graphing is not supported yet",
		);
		next;
	}

	DEBUG "found node=$id, type=$type";

	# Here's the most common case : only plain plugins
	my $sth;

	$sth = $dbh->prepare_cached("SELECT value FROM service_attr WHERE id = ? and name = ?");
	$sth->execute($id, "graph_title");
	my ($graph_title) = $sth->fetchrow_array();

	$sth->execute($id, "graph_period");
	my ($graph_period) = $sth->fetchrow_array();
	$graph_period = "second" unless $graph_period;

	# Note that graph_vtitle is *NOT* supported anymore
	$sth->execute($id, "graph_vlabel");
	my ($graph_vlabel) = $sth->fetchrow_array();
	$graph_vlabel =~ s/\$\{graph_period\}/$graph_period/g;

	$sth->execute($id, "graph_order");
	my ($graph_order) = $sth->fetchrow_array();
	DEBUG "graph_order: $graph_order";

	$sth->execute($id, "graph_args");
	my ($graph_args) = $sth->fetchrow_array();
	DEBUG "graph_args: $graph_args";

	$sth->execute($id, "graph_printf");
	my ($graph_printf) = $sth->fetchrow_array();
	if (! defined $graph_printf) {
		# If the base unit is 1024 then 1012.56 is a valid
		# number to show.  That's 7 positions, not 6.
		$graph_printf = ($graph_args =~ /--base\s+1024/) ? "%7.2lf" : "%6.2lf";
	}

	DEBUG "graph_printf: $graph_printf";

	$sth = $dbh->prepare_cached("
		SELECT
			ds.name,
			l.value,
			rf.value,
			rd.value,
			rc.value,
			gc.value,
			gd.value,
			pf.value,
			'dummy' as dummy
		FROM ds
		LEFT OUTER JOIN ds_attr l ON l.id = ds.id AND l.name = 'label'
		LEFT OUTER JOIN ds_attr rf ON rf.id = ds.id AND rf.name = 'rrd:file'
		LEFT OUTER JOIN ds_attr rd ON rd.id = ds.id AND rd.name = 'rrd:field'
		LEFT OUTER JOIN ds_attr rc ON rc.id = ds.id AND rc.name = 'rrd:cdef'
		LEFT OUTER JOIN ds_attr gc ON gc.id = ds.id AND gc.name = 'gfx:color'
		LEFT OUTER JOIN ds_attr gd ON gd.id = ds.id AND gd.name = 'gfx:draw'
		LEFT OUTER JOIN ds_attr pf ON pf.id = ds.id AND pf.name = 'printf'
		WHERE ds.service_id = ?
	");
	$sth->execute($id);

	# Construction of the RRD command line
	# We don't care anymore for rrdtool less than 1.4
	my @rrd_def;
	my @rrd_gfx;
	my @rrd_legend;

	my $field_number = 0;
	while (my ($_name, $_label, $_rrdfile, $_rrdfield, $_rrdcdef, $_color, $_drawtype, $_printf) = $sth->fetchrow_array()) {
		my $rrdname = $_name;

		# Plugins can override this via "graph_printf"
		$_printf = $graph_printf unless defined $_printf;

		DEBUG "rrdname: $rrdname";

		# Fetch the data
		push @rrd_def, "DEF:avg_$rrdname=" . $_rrdfile . ":" . $_rrdfield . ":AVERAGE";
		push @rrd_def, "DEF:min_$rrdname=" . $_rrdfile . ":" . $_rrdfield . ":MIN";
		push @rrd_def, "DEF:max_$rrdname=" . $_rrdfile . ":" . $_rrdfield . ":MAX";

		# Graph
		$_color = $COLOUR[$field_number++ % $#COLOUR] unless defined $_color;
		$_drawtype = "LINE" unless defined $_drawtype;
		push @rrd_gfx, "$_drawtype:avg_$rrdname#$_color:$_label";

		# Legend
		push @rrd_def, "VDEF:vavg_$rrdname=avg_$rrdname,AVERAGE";
		push @rrd_def, "VDEF:vmin_$rrdname=min_$rrdname,MINIMUM";
		push @rrd_def, "VDEF:vmax_$rrdname=max_$rrdname,MAXIMUM";

		push @rrd_def, "VDEF:vlst_$rrdname=avg_$rrdname,LAST";
		push @rrd_def, "VDEF:v95p_$rrdname=avg_$rrdname,95,PERCENT";

		push @rrd_gfx, "COMMENT: Cur\\:";
		push @rrd_gfx, "GPRINT:vlst_$rrdname:$_printf";
		push @rrd_gfx, "COMMENT: Min\\:";
		push @rrd_gfx, "GPRINT:vmin_$rrdname:$_printf";
		push @rrd_gfx, "COMMENT: Avg\\:";
		push @rrd_gfx, "GPRINT:vavg_$rrdname:$_printf";
		push @rrd_gfx, "COMMENT: Max\\:";
		push @rrd_gfx, "GPRINT:vmax_$rrdname:$_printf" . "\\j";
	}

	# Send the HTTP Headers
	print header(
		-status => 200,
		"Content-type" => "image/png",
	) unless CGI::url_param("no_header");

	# Compute the title
	my $title = "";
	if ($time eq "pinpoint") {
		my $start_text = localtime($start);
		my $end_text = localtime($end);
		$title = "from $start_text to $end_text";
	} else {
		$title = "by " . $time;
	}

	my @rrd_header = (
		"--title", "$graph_title - $title",
		"--watermark", "Munin " . $Munin::Common::Defaults::MUNIN_VERSION,
		"--imgformat", uc($format),
		"--start", $start,
		"--vertical-label", $graph_vlabel,
		"--slope-mode",
		"--imginfo", "",
	);
	push @rrd_header, "--end" , $end if $end;

	use File::Temp;
	my $rrd_fh = File::Temp->new();
	# Send the PNG output
	my $tpng = Time::HiRes::time;
	my @rrd_cmd = (
		$rrd_fh->filename,
		@rrd_header,
		@rrd_def,
		@rrd_gfx,
		@rrd_legend,
	);

	use RRDs;
	RRDs::graph(
		@rrd_cmd,
	);
	if ($!) {
		ERROR "Error generating image: $!";
		INFO "@rrd_cmd";
	};

	# Sending the file
	DEBUG "sending '$rrd_fh->filename'";
	$rrd_fh->seek( 0, SEEK_SET );
	{
		my $buffer;
		# No buffering wanted when sending the file
		local $| = 1;
		while (sysread($rrd_fh, $buffer, 40 * 1024)) { print $buffer; }
	}

	my $ttot = Time::HiRes::time;
	DEBUG sprintf("total:%.3fs (db:%.3fs rrd:%.3fs)",
		($ttot - $t0),
		($tpng - $t0),
		($ttot - $tpng),
	);
}

sub remove_dups {
	my ($str) = @_;

	my @a = split(/ +/, $str);
	my %seen;
	@a = grep { ! ($seen{$_}++) } @a;

	return join(" ", @a);
}

# CGI in perl 5.20 is now seriously broken as it doesn't import into the namespace.
# So we have to delegate explicitely. It's easier than prefixing with CGI:: each use.
sub header { return CGI::header(@_); }
sub path_info { return CGI::path_info(@_); }
sub url { return CGI::url(@_); }
sub script_name { return CGI::script_name(@_); }
sub url_param { return CGI::url_param(@_); }
